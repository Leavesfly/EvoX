# 核心概念

<cite>
**本文档引用的文件**
- [Agent.java](file://evox-agents/src/main/java/io/leavesfly/evox/agents/base/Agent.java)
- [Workflow.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/base/Workflow.java)
- [WorkflowGraph.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/graph/WorkflowGraph.java)
- [WorkflowExecutor.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/execution/WorkflowExecutor.java)
- [Memory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/base/Memory.java)
- [ShortTermMemory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/shortterm/ShortTermMemory.java)
- [LongTermMemory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/longterm/LongTermMemory.java)
- [RAGEngine.java](file://evox-rag/src/main/java/io/leavesfly/evox/rag/RAGEngine.java)
- [Message.java](file://evox-core/src/main/java/io/leavesfly/evox/core/message/Message.java)
- [Action.java](file://evox-actions/src/main/java/io/leavesfly/evox/actions/base/Action.java)
- [ActionAgentExample.java](file://evox-examples/src/main/java/io/leavesfly/evox/examples/ActionAgentExample.java)
- [WorkflowDemo.java](file://evox-examples/src/main/java/io/leavesfly/evox/examples/WorkflowDemo.java)
- [MemoryAgentExample.java](file://evox-examples/src/main/java/io/leavesfly/evox/examples/MemoryAgentExample.java)
</cite>

## 目录
1. [简介](#简介)
2. [智能代理（Agent）架构](#智能代理agent架构)
3. [工作流（Workflow）编排](#工作流workflow编排)
4. [记忆管理系统](#记忆管理系统)
5. [RAG检索增强生成引擎](#rag检索增强生成引擎)
6. [消息传递机制](#消息传递机制)
7. [组件协作](#组件协作)
8. [总结](#总结)

## 简介

EvoX是一个强大的AI应用框架，提供了完整的智能代理、工作流编排、记忆管理和检索增强生成能力。本文档深入解析EvoX的核心概念，展示各个组件如何协同工作以构建复杂的AI应用程序。

## 智能代理（Agent）架构

### Agent基类设计

智能代理是EvoX框架的核心组件，负责执行特定的任务和动作。Agent基类提供了统一的接口和基础设施。

```mermaid
classDiagram
class Agent {
+String agentId
+String name
+String description
+LLMConfig llmConfig
+BaseLLM llm
+String systemPrompt
+Action[] actions
+Map~String,Action~ actionMap
+boolean isHuman
+execute(String actionName, Message[] messages) Message
+executeAsync(String actionName, Message[] messages) Mono~Message~
+getAction(String actionName) Action
+addAction(Action action) void
+removeAction(String actionName) void
}
class ActionAgent {
+Function~Map~String,Object~,Map~String,Object~~ executeFunction
+ParameterSpec[] inputSpecs
+ParameterSpec[] outputSpecs
+boolean validateInputs
+boolean validateOutputs
+call(Map~String,Object~ inputs) Message
}
class CustomizeAgent {
+String prompt
+execute(String actionName, Message[] messages) Message
}
class PlanAgent {
+execute(String actionName, Message[] messages) Message
}
Agent <|-- ActionAgent
Agent <|-- CustomizeAgent
Agent <|-- PlanAgent
```

**图表来源**
- [Agent.java](file://evox-agents/src/main/java/io/leavesfly/evox/agents/base/Agent.java#L26-L152)
- [ActionAgentExample.java](file://evox-examples/src/main/java/io/leavesfly/evox/examples/ActionAgentExample.java#L47-L258)

### 动作（Action）执行机制

动作是Agent执行的具体操作单元，每个动作都有明确的输入和输出规范。

```mermaid
sequenceDiagram
participant Client as 客户端
participant Agent as 智能代理
participant Action as 动作
participant LLM as 语言模型
Client->>Agent : execute(actionName, messages)
Agent->>Agent : getAction(actionName)
Agent->>Action : execute(input)
Action->>Action : 验证输入参数
Action->>LLM : 调用语言模型
LLM-->>Action : 返回结果
Action->>Action : 验证输出结果
Action-->>Agent : ActionOutput
Agent->>Agent : 构建Message响应
Agent-->>Client : Message
```

**图表来源**
- [Agent.java](file://evox-agents/src/main/java/io/leavesfly/evox/agents/base/Agent.java#L96-L103)
- [Action.java](file://evox-actions/src/main/java/io/leavesfly/evox/actions/base/Action.java#L40-L71)

### 与LLM的集成

Agent可以与各种语言模型集成，提供强大的自然语言处理能力：

- **配置灵活性**：支持多种LLM提供商（OpenAI、阿里云、LiteLLM等）
- **提示词管理**：可配置系统提示词和动态上下文
- **异步执行**：支持异步动作执行，提高并发性能

**节来源**
- [Agent.java](file://evox-agents/src/main/java/io/leavesfly/evox/agents/base/Agent.java#L47-L60)
- [Action.java](file://evox-actions/src/main/java/io/leavesfly/evox/actions/base/Action.java#L36-L38)

## 工作流（Workflow）编排

### DAG（有向无环图）架构

工作流通过有向无环图（DAG）来组织和编排复杂的业务流程，支持多种节点类型和执行策略。

```mermaid
graph TD
subgraph "工作流图结构"
A[开始节点] --> B[动作节点]
B --> C[决策节点]
C --> D[并行节点]
C --> E[动作节点]
D --> F[循环节点]
D --> G[动作节点]
F --> H[结束节点]
E --> H
G --> H
end
subgraph "节点类型"
I[ACTION - 动作节点]
J[DECISION - 决策节点]
K[PARALLEL - 并行节点]
L[LOOP - 循环节点]
M[SUBWORKFLOW - 子工作流节点]
end
```

**图表来源**
- [WorkflowGraph.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/graph/WorkflowGraph.java#L1-L326)
- [WorkflowDemo.java](file://evox-examples/src/main/java/io/leavesfly/evox/examples/WorkflowDemo.java#L57-L324)

### 节点和边的关系管理

工作流图维护节点之间的依赖关系，确保正确的执行顺序：

```mermaid
flowchart TD
Start([开始执行]) --> FindInitial["查找初始节点"]
FindInitial --> HasInitial{"是否有初始节点?"}
HasInitial --> |否| Error["抛出异常"]
HasInitial --> |是| MarkReady["标记为就绪"]
MarkReady --> GetReady["获取就绪节点"]
GetReady --> HasReady{"是否有就绪节点?"}
HasReady --> |否| Wait["等待条件满足"]
HasReady --> |是| SelectNode["选择执行节点"]
SelectNode --> ExecuteNode["执行节点"]
ExecuteNode --> UpdateGraph["更新图状态"]
UpdateGraph --> CheckComplete{"是否完成?"}
CheckComplete --> |否| FindNext["查找下一个节点"]
CheckComplete --> |是| Complete["完成执行"]
FindNext --> GetReady
Wait --> GetReady
```

**图表来源**
- [WorkflowExecutor.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/execution/WorkflowExecutor.java#L54-L89)
- [WorkflowGraph.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/graph/WorkflowGraph.java#L116-L131)

### 执行上下文管理

工作流执行过程中维护详细的执行上下文，包括：

- **状态跟踪**：记录每个节点的执行状态（PENDING、READY、RUNNING、COMPLETED、FAILED）
- **进度监控**：实时计算工作流执行进度
- **错误处理**：捕获和报告执行过程中的错误
- **资源管理**：管理Agent和Action的生命周期

**节来源**
- [Workflow.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/base/Workflow.java#L66-L88)
- [WorkflowExecutor.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/execution/WorkflowExecutor.java#L36-L49)

## 记忆管理系统

### 短期和长期记忆架构

EvoX提供了完整的记忆管理解决方案，支持短期和长期记忆的分离存储和访问。

```mermaid
classDiagram
class Memory {
<<abstract>>
+clear() void
}
class ShortTermMemory {
+String memoryId
+Message[] messages
+int maxMessages
+addMessage(Message message) void
+getMessages() Message[]
+getLatestMessages(int n) Message[]
+resize(int newMaxSize) void
+clear() void
}
class LongTermMemory {
+VectorStore vectorStore
+EmbeddingService embeddingService
+boolean initialized
+storeMessage(Message message) void
+searchSimilar(String query, int topK) Message[]
+clear() void
}
Memory <|-- ShortTermMemory
Memory <|-- LongTermMemory
```

**图表来源**
- [Memory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/base/Memory.java#L1-L18)
- [ShortTermMemory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/shortterm/ShortTermMemory.java#L1-L237)
- [LongTermMemory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/longterm/LongTermMemory.java#L1-L155)

### 短期记忆实现

短期记忆用于存储工作流执行过程中的临时消息，具有以下特点：

- **容量限制**：可配置最大消息数量，超出时自动移除最旧的消息
- **快速访问**：支持高效的最新消息检索
- **分类查询**：可根据智能体或动作名称过滤消息
- **动态调整**：支持运行时调整存储容量

### 长期记忆实现

长期记忆使用向量存储技术，提供语义化的记忆检索能力：

- **向量化存储**：将消息内容转换为高维向量进行存储
- **语义检索**：基于向量相似度进行语义匹配
- **持久化**：支持多种向量数据库后端（FAISS、Chroma、Qdrant等）
- **元数据管理**：存储消息的完整元数据用于精确检索

**节来源**
- [ShortTermMemory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/shortterm/ShortTermMemory.java#L44-L88)
- [LongTermMemory.java](file://evox-memory/src/main/java/io/leavesfly/evox/memory/longterm/LongTermMemory.java#L53-L121)

## RAG检索增强生成引擎

### 文档处理和向量化

RAG引擎提供了完整的检索增强生成解决方案，支持多种文档格式和检索策略。

```mermaid
flowchart TD
A[文档输入] --> B[文档读取器]
B --> C[分块器]
C --> D[嵌入服务]
D --> E[向量存储]
F[查询输入] --> G[查询处理]
G --> H[向量检索]
H --> I[相似度计算]
I --> J[结果排序]
J --> K[重排序器]
K --> L[最终结果]
E --> H
```

**图表来源**
- [RAGEngine.java](file://evox-rag/src/main/java/io/leavesfly/evox/rag/RAGEngine.java#L66-L146)

### 检索策略

RAG引擎支持多种检索策略以适应不同的应用场景：

- **固定大小分块**：按固定字节数分割文档
- **语义分块**：基于语义相似度智能分割
- **混合检索**：结合多种检索策略提高准确性
- **重排序**：使用更精确的算法优化检索结果

### 语义检索机制

```mermaid
sequenceDiagram
participant User as 用户
participant RAG as RAG引擎
participant Reader as 文档读取器
participant Chunker as 分块器
participant Embedder as 嵌入服务
participant VectorStore as 向量存储
User->>RAG : 提交查询
RAG->>Embedder : 生成查询向量
RAG->>VectorStore : 向量相似度检索
VectorStore-->>RAG : 返回候选片段
RAG->>RAG : 重排序候选结果
RAG-->>User : 返回最佳匹配
```

**图表来源**
- [RAGEngine.java](file://evox-rag/src/main/java/io/leavesfly/evox/rag/RAGEngine.java#L127-L156)

**节来源**
- [RAGEngine.java](file://evox-rag/src/main/java/io/leavesfly/evox/rag/RAGEngine.java#L1-L269)

## 消息传递机制

### 消息类型和结构

EvoX使用统一的消息格式在各个组件间传递信息，支持多种消息类型和丰富的元数据。

```mermaid
classDiagram
class Message {
+String messageId
+Object content
+MessageType messageType
+String agent
+String action
+String prompt
+Instant timestamp
+String workflowGoal
+String workflowTask
+String workflowTaskDesc
+String[] nextActions
+inputMessage(Object content) Message
+outputMessage(Object content) Message
+responseMessage(Object content, String agent, String action) Message
+errorMessage(String errorMsg) Message
+systemMessage(String content) Message
}
class MessageType {
<<enumeration>>
INPUT
OUTPUT
RESPONSE
ERROR
SYSTEM
UNKNOWN
}
Message --> MessageType
```

**图表来源**
- [Message.java](file://evox-core/src/main/java/io/leavesfly/evox/core/message/Message.java#L1-L136)

### 消息流转模式

消息在EvoX框架中按照特定的模式流转，确保信息的准确传递和状态同步：

- **输入消息**：工作流输入或用户请求
- **响应消息**：Agent或Action的执行结果
- **系统消息**：框架内部状态通知
- **错误消息**：异常情况的错误报告

**节来源**
- [Message.java](file://evox-core/src/main/java/io/leavesfly/evox/core/message/Message.java#L86-L134)

## 组件协作

### 整体架构协同

EvoX的各个组件通过精心设计的接口和消息传递机制实现无缝协作：

```mermaid
graph TB
subgraph "用户层"
U[用户请求]
end
subgraph "控制层"
W[工作流]
WE[工作流执行器]
WG[工作流图]
end
subgraph "执行层"
A[智能代理]
AC[动作集合]
M[记忆管理器]
end
subgraph "服务层"
RAG[RAG引擎]
S[存储服务]
LLM[语言模型]
end
U --> W
W --> WE
WE --> WG
WG --> A
A --> AC
A --> M
AC --> RAG
M --> S
A --> LLM
WE --> U
```

### 协作流程示例

以下是一个典型的EvoX应用执行流程：

```mermaid
sequenceDiagram
participant User as 用户
participant WF as 工作流
participant Exec as 执行器
participant Agent as 智能代理
participant Memory as 记忆系统
participant RAG as RAG引擎
participant LLM as 语言模型
User->>WF : 提交请求
WF->>Exec : 开始执行
Exec->>Agent : 调用动作
Agent->>Memory : 获取上下文记忆
Memory-->>Agent : 返回相关记忆
Agent->>RAG : 检索外部知识
RAG-->>Agent : 返回检索结果
Agent->>LLM : 生成响应
LLM-->>Agent : 返回生成内容
Agent-->>Exec : 返回执行结果
Exec-->>WF : 更新工作流状态
WF-->>User : 返回最终结果
```

**图表来源**
- [WorkflowDemo.java](file://evox-examples/src/main/java/io/leavesfly/evox/examples/WorkflowDemo.java#L42-L324)
- [WorkflowExecutor.java](file://evox-workflow/src/main/java/io/leavesfly/evox/workflow/execution/WorkflowExecutor.java#L213-L237)

### 性能优化策略

EvoX在设计时考虑了多种性能优化策略：

- **异步执行**：支持异步动作执行，提高并发性能
- **缓存机制**：智能缓存频繁访问的数据和计算结果
- **资源池化**：复用LLM连接和计算资源
- **流式处理**：支持流式数据处理，减少延迟

## 总结

EvoX框架通过其核心概念的有机结合，为构建复杂的AI应用程序提供了强大而灵活的基础设施：

1. **智能代理**提供了统一的任务执行接口，支持多种类型的智能体
2. **工作流编排**通过DAG架构实现了复杂业务流程的自动化
3. **记忆管理**确保了上下文的连续性和知识的持久化
4. **RAG引擎**增强了系统的知识获取和推理能力
5. **消息传递**保证了组件间的可靠通信

这些核心概念相互协作，形成了一个完整的AI应用开发生态系统，使开发者能够专注于业务逻辑的实现，而不必担心底层的技术细节。通过这种模块化的设计，EvoX既保持了高度的灵活性，又确保了系统的稳定性和可扩展性。